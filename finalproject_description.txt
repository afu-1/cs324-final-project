Final Project Description

Group Flappy Dino created a game called "Flappy Dino," which takes inspiration from the Google Chrome offline dinosaur game and the mobile game "Flappy Bird."

The game functionality is as follows:
1. Upon running the Processing file, a main menu screen will appear, which allow the user to enter a name for their dinosaur as well as choose the dinosaur's color by clicking on one of the color options on the screen.
2. Once the player clicks on a color option, the game will begin. The player will be given control of the dinosaur through the up and down arrow keys (the up arrow key will move the dinosaur up, and the down arrow key will move the dinosaur down). The dinosaur must avoid the red projectiles in order to stay alive.
3. If the dinosaur touches a red projectile, the game ends. A game over screen will appear with how long the player kept the dinosaur alive (their score) and previous scores from previous iterations of gameplay will also be displayed.

The basic requirements are summarized below:
1. Keyboard functionality: pressing the up arrow key will cause the dinosaur to move up and pressing the down arrow will cause the dinosaur to move down.
2. Multiple GUI systems: there will be a main menu screen upon running the Processing file where the user will be able to enter a dinosaur name and pick a color for the dinosaur, an in-game screen with the player’s score displayed, and a game over screen displaying the player’s score and other users’ high scores from previous iterations of gameplay.
3. Class objects with animation hierarchies: the dinosaur’s tail will wiggle up and down relative to the dinosaur’s body and the dinosaur’s wings will flap. Both of these animations will last indefinitely while the dinosaur is still or when moving through the use of the arrow keys.
4. Data input/output: on the character customization screen, the user can input the dinosaur’s name and choose the dinosaur’s color. The high scores of previous iterations of gameplay will also be saved. The dinosaur’s colors will be stored in a JSON array, while the high scores will be saved in a CSV file.
5. Sound: once gameplay starts, a super chill vibe Lofi song will be played. Once the game ends, the song will stop. The song is also pausable by pressing the lowercase “m” key.

Jose: I was in charge of creating the projectiles, creating the background scene, and implementing the music functionality. For the projectiles, I created a Car class, which is a modified version of the Car class that I used in Assignment 7. A Car object has a position vector, a velocity vectork, a scaling factor to change its size, a width, and a height. Besides the constructor, I have a move() function which moves the Car object according to its velocity vector, a display() function to display the Car object, a isOutOfBounds() function to check whether the Car object has gone off-screen, and a respawn() function to respawn the Car object if it has gone off-screen. For the background, I created a Ground class, a Cloud class, and a Tree class. The Ground class simply displays a ground for the background. The Cloud class and the Tree class are both subclasses of the Car class. Both have the same functionality as the Car class, except their display() functions have been changed. For the Cloud class, the display() function displays a cloud; for the Tree class, the display() function displays a tree. As for the music functionality, I used minim to implement this. The music will start only when the player proceeds into the in-game screen. The music is togglable by pressing the lowercase "m" key. The music functionality will continue into the game over screen.

Annie: I was in charge of creating the colors dataset and scores class. For the colors dataset, I first created a JSON file to contain the color values. However, I ran into the issue of transforming the string hexcodes into the actual color integer so I resorted to changing the values into their RGB number values. From there, I tried to store the values into local dictionaries (where each RGB value had its own dictionary value) until I realized that a hashmap would be easier for storage. Afterwords, I started to work on the scores dataset where I had to relearn how to create a CSV file. From there, I ran into the challenge of displaying the scores sheet with new input values as a new row would have to coded in. As a result, I decided to create a class that handled all of the new score functionality and the displaying of scores. Theoretically, if the game would be able to reset, then saved high scores would be saved; however, Processing constantly resets the csv files with every time it runs, so it's difficult to transfer over old plays from old runs of the game.oud 


Anthony: I created the GUIS for the game. The main gui is the startscreen of the game. The start screen requires multiple buttons to be added to the screeen that allow the user to choose the color of the dino. There is also functionality added that allows for a name to be created for the player. Creating the function to take the input of the name was slightly difficult becuase processing does no allow for input into the console like most other programming languages do. In order to create this functionality I had to use the keypressed functions included in processing. The next GUI was the timer. The timer was fairly straight forward to implement however originally we had a pause function that was included into the timer. However, the pause functionality proved difficult for my other team memebers and I and to implement so it was abandoned. The last GUI is the end screen that will display the end game score (the time on the timer) and the name of character. This screen was fairly simple to implement and worked well.

Ally: I was in charge of creating the main character sprite as well as its animation hierarchies (the tail and wing flap in the wind); its keyboard functionality (up and down arrow keys); and implementing the color hashmap that Annie created to change the color of the Dino based on which button the user clicked. The classes associated with the main character were Tail, FrontWing, DinoBody, and Dino. Three methods used for the animation hierarchy were bounce(), which was used to make the object flap, while up() and down() were used to translate the object as a whole based on keyPressed. A filler parameter was given to the Button class in order to pass color onto the Dino based on which Button on the main screen was pressed. The Dino class is a composite class that makes tying the other classes together simpler—it calls methods for all of the Dino body parts passed into it. I also implemented collision detection inside Dino to make sure the hit box moves with the characters. OverEnemy is a boolean where collision detection is determined, and it is consistently called within checkHealth() in main—I reused this code from my assignment 7 game.